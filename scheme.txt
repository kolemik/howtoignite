User
	*id
	*name
	*accoutIdIn
	*accoutIdOut

Account
	*id
	*userId
	*type
	*currency

Ballance
	*accountId
	*lastBallance балланс можно считать по сумме транзакций
	*lastTransactionId

Transaction
	*id
	*type
	*timestamp
	*accountIdFrom
	*accountIdTo              сумма которую отправляли
	*fromAmount == fromFee + (toFee     +     toAmount)
	*toAmount
	*fromFee -- комиссия на отправителе
	*toFee -- комиссия на получателе
	
Для перевода блокируется только балланс пользователя по конкретному счёту с которого идёт списание

Обновление счёта получателя идёт не транзакционно

Номер транзакции как?

При обновлении балланса смотрим там текущую транзакцию, находим её, находим все остальные транзакции у которых таймстэмп выше (может быть ссылки делать между ними?). учитываем (это если деньги переводили на наш счёт). Теперь у нас есть полная сумма на момент начала новой транзакции. -- бред всё

************
Балланс отправителя кэшируем и обновляем транзакционно -- главное забрать у пользователя бабло

Транзакцию просчитываем со стороны отправителя и отправляем её ID обработчику в очередь
	реализация очередей в игнайте?
		нельзя ли просто подписаться на ивент EventType.EVT_CACHE_OBJECT_PUT

обработчик вычитывает очередь, берёт из кэша транзакцию и зачисляет её на балланс (тразакционно!) После чего выполняет разные там действия, рассылка-то-сё.
	при ошибке зачисления (нет адресата, заблокирован, превышены лимиты итп) -- инициируется транзакция отмены
	при удаче -- меняется статус транзакции и посылается нотификация отправителю

Персистентными должны быть только транзакции? восстановления балланса по транзакциям? аггрегирующие транзакции за период?

Региональные кэши? Что с ними? Возможно ли это решить путём пачки подписчиков-ретрансляторов? что там с множественными получениями нотификаций и фильтрами?
*************

Тест
	пользователи а-б-с с баллансами 10-20-30
	переводы от одного-другому
	сверка сумм
	просмотр журнала транзакций

